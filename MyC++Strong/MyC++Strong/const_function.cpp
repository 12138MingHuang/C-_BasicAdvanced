//const修饰函数返回值
//(1)const int
const int func1();

//(2)const int*
const int* func2(); //指针指向的内容不可变

//(3)int* const
int* const func3(); //指针本身不可变


//const修饰函数参数
//(1)传递过来的参数及指针本身在函数内不可变
void func4(const int a); //传递过来的参数不可变
void func5(int* const b); //指针本身不可变

//(2)传递过来的参数及指针指向的内容在函数内不可变
void StringCopy(char* dst, const char* src); 
//其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。

//(3)参数为引用，为了增加效率同时防止修改
void func6(const int& a); //传递过来的参数不可变


//const修饰函数,使得函数重载
void print();
//void print() const; //只得在类的成员函数中使用，表示该函数不会修改类的成员变量

//对于非内部数据类型的参数而言，像void func(A a) 这样声明的函数注定效率比较低。
//因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。
//为了提高效率，可以将函数声明改为void func(A& a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临 时对象。

//但是函数void func(A& a) 存在一个缺点：
//“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A& a)。
//以此类推，是否应将void func(int x) 改写为void func(const int& x)，以便提高效率？
//完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。

//小结：
//1.对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。
//例如将void func(A a) 改为void func(const A & a)。
//2.对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。
//否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int& x)。


//问题1：如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别；
// 1------------------------------------------
//非 const 指针：如果你不希望函数修改通过指针指向的数据，你可以使用非 const 指针。这表示函数可以修改指针所指向的数据。
//void modifyData(int* data); // 非 const 指针，函数可以修改 data 指向的数据
// 2------------------------------------------
//const 指针：如果你希望函数不能修改通过指针指向的数据，你可以使用 const 指针。这表示函数不可以修改指针所指向的数据，但可以修改指针本身。
//void readData(const int* data); // const 指针，函数不可以修改 data 指向的数据
// 3------------------------------------------
//指向 const 数据的指针：如果你希望函数不可以修改指针本身，你可以将 const 放在数据类型后面。
//void readData(int* const data); // 函数不可以修改 data 指针本身
// 4------------------------------------------
//const 指针指向 const 数据：如果你希望函数不可以修改通过指针指向的数据，同时也不可以修改指针本身，你可以将 const 放在数据类型前面和指针本身前面。
//void constRead(const int* const data); // 函数不可以修改 data 指向的数据和指针本身


//问题2：如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const。
//当你的函数需要传入复杂类型的实例时，你可以选择使用值参数或引用参数，具体取决于你的需求和性能考虑。
//这里有一些关于值参数和引用参数之间的区别：
// ------------------------------------------
//值参数（pass by value）：
//复制成本：当你将参数传递给函数时，会创建参数的一个副本，这可能涉及到复制整个对象，特别是对于大型对象来说，会有一定的性能开销。
//数据的不可变性：如果你将参数作为值传递给函数，函数无法修改原始对象，因为它操作的是一个副本。这对于保护原始数据的一致性很有用。
// ------------------------------------------
//引用参数（pass by reference）：
//避免复制成本：引用参数传递的是对象的引用，而不是副本，因此没有复制成本。这对于大型对象或复杂对象来说，可以提高性能。
//允许在函数内修改原始对象：如果你希望函数能够修改传入的对象，使用引用参数是必要的，因为它允许函数在调用之后修改原始对象。
// ------------------------------------------
//带有 const 修饰符的引用参数：
//如果你想确保函数在内部不会修改传入的对象，可以使用带有 const 修饰符的引用参数。这告诉编译器函数不会修改传入的对象，
//这在保护数据的一致性方面非常有用。带有 const 修饰符的引用参数的语法如下：
//void func(const ComplexType& obj);
//这里，obj 是一个常量引用，函数内部不能修改 obj 所引用的对象。
// ------------------------------------------
//总之，你的选择取决于你的需求。如果函数不需要修改传入的对象且不希望复制成本，可以使用带有 const 的引用参数。
//如果函数需要修改传入的对象或者你不希望复制成本，可以使用非带有 const 修饰符的引用参数。
//如果你希望对象保持不变，并且不关心复制成本，可以使用值参数。
