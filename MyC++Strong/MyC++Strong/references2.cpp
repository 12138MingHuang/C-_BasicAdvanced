/**
 * @file references2.cpp
 * @brief 引用与指针
 * 引用: 必须初始化,不能为空，不能更换目标
 * 指针: 可以不初始化，可以为空，可以更换目标
 * @auther bin.zhang
 * @date 2024.05.31
 */

// 左值引用
// 常规引用，一般表示对象的身份

// 右值引用
// 右值引用就是必须绑定到右值(一个临时对象，将要销毁的对象)的引用，一般表示对象的值
// 右值引用可以实现转移语义和精准传递，它的主要目的右两个方面
	// 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
	// 能够更简洁明确地定义泛型函数

// 引用折叠
	// X& &、X& &&、X&& &可折叠成X&
	// X&& &&可折叠成X&&

// C++的引用在减少了程序员自由度的同时提升了内存操作的安全性和语义的优美性。
// 比如引用强制要求必须初始化，可以让我们在使用引用的时候不用再去判断引用是否为空，让代码更加优美简洁，避免指针满天飞的情形

// 引用型参数
// 一般使用const reference作为函数参数的形式，表示函数对参数的修改是不允许的，只能读取。
// 这种情况下既可以避免拷贝还可以获得与传值参数一样的调用方式

#include <iostream>
#include <vector>

using namespace std;

void test(const vector<int>& data) {
	// do something
}

int main() {
	vector<int> data{1, 2, 3, 4, 5, 6, 7, 8};
	test(data);

	return 0;
}

// 引用型返回值
// C++提供了重载运算符的功能，在重载某些操作符的时候，使用引用型返回值可以获得跟该操作符原来语法相同的调用方式
// 保持了操作符语义的一致性。一个例子就是operator []操作符，这个操作符一般需要返回一个引用对象，才能正确的被修改
vector<int> v(10);
//v[5] = 10; // []操作符返回引用，然后vector对应元素才能被修改
		   // 如果操作符[]不返回引用而是指针的话，赋值语句则需要这样写
//*v[5] = 10; // 这种书写方式，完全不符合我们对[]调用的认知，容易产生误解