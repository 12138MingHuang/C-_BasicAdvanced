/**
 * 空类的大小为1字节
 * 一个类中，虚函数本身、成员函数(包括静态与非静态)和静态数据成员都不占用类对象的存储空间
 * 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针，vptr的大小，这个虚指针指向一个虚函数表，虚函数表是一个一维数组，存放着每个虚函数的入口地址
 * 普通继承，派生类继承了所以基类的函数和成员，要按照字节对齐的方式，如果派生类中有虚函数，还要加上一个指针vptr，指向虚函数表
 * 虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr，指向虚函数表。(32位系统，指针占4字节，64位系统，指针占8字节)
 * 虚继承，继承基类的vptr。
 */
//char: 1字节
//int : 4字节(32位) 8字节(64位)
//short : 2字节
//long : 4字节(32位) 8字节(64位)
//long long : 8字节
//float : 4字节
//double : 8字节
//long double : 8字节
//bool : 1字节，通常表示为true或false
//vptr指针：指向虚函数表的指针，占8字节


//内存对齐规则是由编译器和硬件架构共同决定的，它确保数据在内存中按照特定的规则排列，以提高访问速度和内存访问的效率。
//1.字节对齐：大多数平台要求基本数据类型（如 char、int、float）在内存中的地址应该是它们自身大小的倍数。
//例如，一个 int 变量通常应该在4字节边界上对齐，即其地址应该是4的倍数。这意味着 int 变量的地址可以是 0、4、8、等等。
//2.结构体对齐：结构体的对齐要求通常是其包含的成员中最大数据类型的大小。
//如果结构体中有一个 double 类型的成员，那么结构体通常会按照 double 的大小进行对齐。
//3.类的虚函数表指针对齐：如果一个类包含虚函数，那么类的对象通常会包含一个指向虚函数表（vtable）的指针。
//虚函数表通常会按照指针大小（4字节或8字节）进行对齐。
//4.自定义对齐规则：在某些情况下，你可以使用编译器提供的指令或属性来自定义对齐规则，如前面所述。
//alignas 关键字可以用于类型、变量、函数和别名声明，用于指定对象在内存中的对齐方式。
//你可以将 alignas 用于类的数据成员来指定它们的对齐方式。例如，假设你想要一个数据成员按照8字节对齐，你可以这样做：
//alignas(8) int myVariable;
//除了使用 alignas 关键字之外，还可以使用 #pragma pack 指令来自定义数据成员的对齐规则。
//#pragma pack 指令告诉编译器按照指定的字节对齐方式对数据成员进行对齐。
/*
#pragma pack(push, n) // 将当前对齐方式入栈，并将对齐方式设置为 n 字节
// 类定义
#pragma pack(pop) // 恢复之前的对齐方式
其中，n 表示指定的对齐字节数。在 #pragma pack(push, n) 后，类中的数据成员将按照 n 字节对齐。在 #pragma pack(pop) 后，恢复之前的对齐方式。*/
/*例如，如果你想要一个数据成员按照4字节对齐，你可以这样做：
#pragma pack(push, 4)
class MyClass {
public:
	int myVariable;
	// 其他成员...
};
#pragma pack(pop)*/

//5.内存对齐的目标是提高内存访问的速度和效率。如果数据没有正确对齐，可能需要多次内存访问才能读取完整的数据，这会增加访问时间。
//因此，了解内存对齐规则对于编写高性能的代码非常重要，尤其是在涉及大型数据结构或涉及底层内存操作的情况下。

/**
 * @file blackclass.cpp
 * @brief 空类的大小为1字节
 * author bin.zhang
 * date 2023-10-30
 */

#include <iostream>

using namespace std;

class A{};
int main()
{
	cout << "sizeof(A) = " << sizeof(A) << endl;
	return 0;
}